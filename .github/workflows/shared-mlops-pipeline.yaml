name: Shared MLOPS Pipeline

on:
  workflow_call:
    inputs:
      model_name:
        description: 'Model name (e.g., wine-classifier)'
        required: true
        type: string
      dvc_data_version:
        description: "Data version to use for training"
        required: true
        type: string
      experiment_name:
        description: 'MLflow experiment name'
        required: true
        type: string
      training_entrypoint:
        description: 'Training script entrypoint'
        required: true
        type: string
      training_args:
        description: 'Additional training arguments'
        required: false
        type: string
        default: ''
      training_image_tag:
        description: 'Training image tag (latest or specific tag like main-abc1234)'
        required: false
        type: string
        default: 'latest'
      serving_image_tag:
        description: 'Serving image tag (latest or specific tag like main-abc1234)'
        required: false
        type: string
        default: 'latest'
      compute_type:
        description: 'Compute configuration'
        required: true
        type: string
      approval_mode:
        description: 'Approval mode (manual or automatic)'
        required: false
        type: string
        default: 'manual'
      comparison_metric:
        description: 'Metric to compare (accuracy, f1_score, etc.)'
        required: false
        type: string
        default: 'accuracy'
      comparison_higher_is_better:
        description: 'Whether higher metric values are better (true/false)'
        required: false
        type: boolean
        default: true
      comparison_threshold:
        description: 'Minimum improvement threshold (e.g., 0.05 = 5%)'
        required: false
        type: string
        default: '0.05'

jobs:
  submit-workflow:
    name: ğŸš€ Submit ML Lifecycle Workflow
    runs-on: self-hosted-local
    steps:
      - uses: OpenCloudHub/.github/actions/setup-kubectl@main
        with:
          kube-config: ${{ secrets.KUBE_CONFIG }}

      - name: Resolve training image
        id: resolve_training
        run: |
          INPUT_TAG="${{ inputs.training_image_tag }}"
          DOCKER_REPO="${{ secrets.DOCKER_USERNAME }}/${{ inputs.model_name }}-training"

          echo "ğŸ” Resolving training image: ${DOCKER_REPO}:${INPUT_TAG}"

          # Get Docker Hub token
          TOKEN=$(curl -s "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${DOCKER_REPO}:pull" \
            | jq -r '.token')

          if [ "$INPUT_TAG" = "latest" ]; then
            echo "ğŸ” Finding latest main-* image..."

            # Get digest of 'latest' tag
            LATEST_DIGEST=$(curl -s \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \
              "https://registry-1.docker.io/v2/${DOCKER_REPO}/manifests/latest" \
              | jq -r '.config.digest')

            if [ "$LATEST_DIGEST" = "null" ] || [ -z "$LATEST_DIGEST" ]; then
              echo "âŒ Could not find 'latest' tag for training image"
              exit 1
            fi

            echo "ğŸ“¦ Latest digest: ${LATEST_DIGEST}"

            # Get all main-* tags
            ALL_TAGS=$(curl -s \
              -H "Authorization: Bearer ${TOKEN}" \
              "https://registry-1.docker.io/v2/${DOCKER_REPO}/tags/list" \
              | jq -r '.tags[]' | grep "^main-" || echo "")

            if [ -z "$ALL_TAGS" ]; then
              echo "âŒ No main-* tags found for training image"
              exit 1
            fi

            # Find matching tag
            RESOLVED_TAG=""
            for tag in $ALL_TAGS; do
              TAG_DIGEST=$(curl -s \
                -H "Authorization: Bearer ${TOKEN}" \
                -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \
                "https://registry-1.docker.io/v2/${DOCKER_REPO}/manifests/${tag}" \
                | jq -r '.config.digest')

              if [ "$TAG_DIGEST" = "$LATEST_DIGEST" ]; then
                RESOLVED_TAG="$tag"
                echo "âœ… Found matching training tag: ${RESOLVED_TAG}"
                break
              fi
            done

            if [ -z "$RESOLVED_TAG" ]; then
              echo "âŒ Could not find main-* tag matching latest digest"
              exit 1
            fi
          else
            RESOLVED_TAG="$INPUT_TAG"
            echo "âœ… Using explicit training tag: ${RESOLVED_TAG}"

            # Validate tag exists
            IMAGE_EXISTS=$(curl -s -o /dev/null -w "%{http_code}" \
              -H "Authorization: Bearer ${TOKEN}" \
              "https://registry-1.docker.io/v2/${DOCKER_REPO}/manifests/${RESOLVED_TAG}")

            if [ "$IMAGE_EXISTS" != "200" ]; then
              echo "âŒ Training image not found: ${DOCKER_REPO}:${RESOLVED_TAG}"
              exit 1
            fi
          fi

          FULL_IMAGE="${DOCKER_REPO}:${RESOLVED_TAG}"
          echo "âœ… Training image: ${FULL_IMAGE}"
          echo "resolved_tag=${RESOLVED_TAG}" >> $GITHUB_OUTPUT
          echo "full_image=${FULL_IMAGE}" >> $GITHUB_OUTPUT

      - name: Resolve serving image
        id: resolve_serving
        run: |
          INPUT_TAG="${{ inputs.serving_image_tag }}"
          DOCKER_REPO="${{ secrets.DOCKER_USERNAME }}/${{ inputs.model_name }}-serving"

          echo "ğŸ” Resolving serving image: ${DOCKER_REPO}:${INPUT_TAG}"

          # Get Docker Hub token
          TOKEN=$(curl -s "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${DOCKER_REPO}:pull" \
            | jq -r '.token')

          if [ "$INPUT_TAG" = "latest" ]; then
            echo "ğŸ” Finding latest main-* image..."

            # Get digest of 'latest' tag
            LATEST_DIGEST=$(curl -s \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \
              "https://registry-1.docker.io/v2/${DOCKER_REPO}/manifests/latest" \
              | jq -r '.config.digest')

            if [ "$LATEST_DIGEST" = "null" ] || [ -z "$LATEST_DIGEST" ]; then
              echo "âŒ Could not find 'latest' tag for serving image"
              exit 1
            fi

            echo "ğŸ“¦ Latest digest: ${LATEST_DIGEST}"

            # Get all main-* tags
            ALL_TAGS=$(curl -s \
              -H "Authorization: Bearer ${TOKEN}" \
              "https://registry-1.docker.io/v2/${DOCKER_REPO}/tags/list" \
              | jq -r '.tags[]' | grep "^main-" || echo "")

            if [ -z "$ALL_TAGS" ]; then
              echo "âŒ No main-* tags found for serving image"
              exit 1
            fi

            # Find matching tag
            RESOLVED_TAG=""
            for tag in $ALL_TAGS; do
              TAG_DIGEST=$(curl -s \
                -H "Authorization: Bearer ${TOKEN}" \
                -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \
                "https://registry-1.docker.io/v2/${DOCKER_REPO}/manifests/${tag}" \
                | jq -r '.config.digest')

              if [ "$TAG_DIGEST" = "$LATEST_DIGEST" ]; then
                RESOLVED_TAG="$tag"
                echo "âœ… Found matching serving tag: ${RESOLVED_TAG}"
                break
              fi
            done

            if [ -z "$RESOLVED_TAG" ]; then
              echo "âŒ Could not find main-* tag matching latest digest"
              exit 1
            fi
          else
            RESOLVED_TAG="$INPUT_TAG"
            echo "âœ… Using explicit serving tag: ${RESOLVED_TAG}"

            # Validate tag exists
            IMAGE_EXISTS=$(curl -s -o /dev/null -w "%{http_code}" \
              -H "Authorization: Bearer ${TOKEN}" \
              "https://registry-1.docker.io/v2/${DOCKER_REPO}/manifests/${RESOLVED_TAG}")

            if [ "$IMAGE_EXISTS" != "200" ]; then
              echo "âŒ Serving image not found: ${DOCKER_REPO}:${RESOLVED_TAG}"
              exit 1
            fi
          fi

          FULL_IMAGE="${DOCKER_REPO}:${RESOLVED_TAG}"
          echo "âœ… Serving image: ${FULL_IMAGE}"
          echo "resolved_tag=${RESOLVED_TAG}" >> $GITHUB_OUTPUT
          echo "full_image=${FULL_IMAGE}" >> $GITHUB_OUTPUT

      - name: Submit Argo Workflow
        id: submit
        run: |
          WORKFLOW_NAME=${{ inputs.model_name }}-$(date +%s)

          cat <<EOF | ~/.local/bin/kubectl create -n mlops -f -
          apiVersion: argoproj.io/v1alpha1
          kind: Workflow
          metadata:
            generateName: ${{ inputs.model_name }}-
            labels:
              repo: ${{ github.event.repository.name }}
              run-id: "${{ github.run_id }}"
              model: "${{ inputs.model_name }}"
          spec:
            serviceAccountName: workflow-executor
            workflowTemplateRef:
              name: mlops-pipeline
            arguments:
              parameters:
              - name: model_name
                value: "${{ inputs.model_name }}"
              - name: experiment_name
                value: "${{ inputs.experiment_name }}"
              - name: dvc_data_version
                value: "${{ inputs.dvc_data_version }}"
              - name: compute_type
                value: "${{ inputs.compute_type }}"
              - name: approval_mode
                value: "${{ inputs.approval_mode }}"
              - name: comparison_metric
                value: "${{ inputs.comparison_metric }}"
              - name: comparison_higher_is_better
                value: "${{ inputs.comparison_higher_is_better }}"
              - name: comparison_threshold
                value: "${{ inputs.comparison_threshold }}"
              - name: training_image
                value: "${{ steps.resolve_training.outputs.full_image }}"
              - name: serving_image
                value: "${{ steps.resolve_serving.outputs.full_image }}"
              - name: training_entrypoint
                value: "${{ inputs.training_entrypoint }}"
              - name: training_args
                value: "${{ inputs.training_args }}"
          EOF

          # Get the actual workflow name
          sleep 2
          ACTUAL_NAME=$(~/.local/bin/kubectl get workflows -n mlops -l repo=${{ github.event.repository.name }},run-id=${{ github.run_id }} -o jsonpath='{.items[0].metadata.name}')
          echo "workflow_name=${ACTUAL_NAME}" >> $GITHUB_OUTPUT

      - name: ğŸ“Š Provide Monitoring Links
        run: |
          WORKFLOW_NAME=${{ steps.submit.outputs.workflow_name }}

          echo "========================================="
          echo "ğŸš€ WORKFLOW SUBMITTED: ${WORKFLOW_NAME}"
          echo "ğŸ¯ Model: ${{ inputs.model_name }}"
          echo "ğŸ§ª Experiment: ${{ inputs.experiment_name }}"
          echo ""
          echo "ğŸ³ IMAGES:"
          echo "  Training: ${{ steps.resolve_training.outputs.full_image }}"
          echo "  Serving:  ${{ steps.resolve_serving.outputs.full_image }}"
          echo ""
          echo "ğŸ“Š Data Version: ${{ inputs.dvc_data_version }}"
          echo "ğŸ’» Compute: ${{ inputs.compute_type }}"
          echo "ğŸ”§ Approval: ${{ inputs.approval_mode }}"
          echo "ğŸ“ˆ Comparison Metric: ${{ inputs.comparison_metric }}"
          echo "ğŸ“Š Threshold: ${{ inputs.comparison_threshold }} (${{ inputs.comparison_higher_is_better && 'higher' || 'lower' }} is better)"
          echo "ğŸš€ Entrypoint: ${{ inputs.training_entrypoint }}"
          echo "âš™ï¸  Args: ${{ inputs.training_args }}"
          echo "========================================="
          echo ""
          echo "ğŸ“Š MONITORING:"
          echo ""
          echo "ğŸŒ Argo Workflow:"
          echo "   https://argo.internal.opencloudhub.org/workflows/ai/${WORKFLOW_NAME}"
          echo ""
          echo "ğŸ”¬ MLflow UI:"
          echo "   https://mlflow.internal.opencloudhub.org"
          echo "   â†’ Navigate to experiment: ${{ inputs.experiment_name }}"
          echo ""
          echo "========================================="
